import ipaddress
import os

from pyramid.view import view_config
from pyramid.httpexceptions import HTTPForbidden
from sqlalchemy.exc import IntegrityError
from wtforms import Form, SelectField, IntegerField, StringField, SubmitField, SelectMultipleField, widgets
from wtforms.validators import InputRequired, Length
from wtforms.widgets.html5 import NumberInput

import pandas as pd

from minisecbgp import models


class MultiCheckboxField(SelectMultipleField):
    widget = widgets.ListWidget(prefix_label=False)
    option_widget = widgets.CheckboxInput()


class AffectedAreaDataForm(Form):
    attacker = SelectField('Choose the <b><i>attacker</i></b> '
                           '(Which AS will announce the hijacked prefix): *',
                           choices=[('', '--'),
                                    ('all', 'All ASs'),
                                    ('region', 'All ASs from a region'),
                                    ('AS', 'Specify the ASN')])
    regionAttacker = StringField('Attacker\'s region name: *',
                                 validators=[InputRequired(),
                                             Length(min=1, max=100,
                                                    message='Region name string must be between 1 and 100 characters long.')])
    ASAttacker = StringField('Attacker\'s ASN: *',
                             validators=[InputRequired(),
                                         Length(min=1, max=100,
                                                message='ASN string must be between 1 and 100 characters long.')])

    target = SelectField('Choose the <b><i>affected area</i></b> '
                         '(Check if this AS receives and accepts the hijacked route): *',
                         choices=[('', '--'),
                                  ('all', 'All ASs'),
                                  ('region', 'All ASs from a region'),
                                  ('AS', 'Specify the ASN')])
    regionTarget = StringField('Target\'s region name: *',
                               validators=[InputRequired(),
                                           Length(min=1, max=100,
                                                  message='Region name string must be between 1 and 100 characters long.')])
    ASTarget = StringField('Target\'s ASN: *',
                           validators=[InputRequired(),
                                       Length(min=1, max=100,
                                              message='ASN string must be between 1 and 100 characters long.')])

    prefix = SelectField('Choose the <b><i>prefix target</i></b> '
                         '(Which prefix will be hijacked): *',
                         choices=[('', '--'),
                                  ('target', 'Use the target\'s prefix'),
                                  ('all', 'All AS\'s prefixes'),
                                  ('region', 'All AS\'s prefixes from a region'),
                                  ('AS', 'Use the prefix of a specific AS'),
                                  ('prefix', 'Enter the prefix')])
    regionPrefix = StringField('Name of the region where all AS\'s prefixes will be hijacked: *',
                               validators=[InputRequired(),
                                           Length(min=1, max=100,
                                                  message='Region name string must be between 1 and 100 characters long.')])
    ASPrefix = StringField('ASN from which its prefix will be hijacked: *',
                           validators=[InputRequired(),
                                       Length(min=1, max=100,
                                              message='ASN string must be between 1 and 100 characters long.')])
    prefixPrefix = StringField('Specific prefix that will be hijacked: *',
                               validators=[InputRequired(),
                                           Length(min=1, max=100,
                                                  message='Prefix string must be between 1 and 100 characters long.')])

    path = SelectField('Number of shortest <b><i>paths</i></b> '
                       '(How many shortest paths should be considered in the report): *',
                       choices=[('', '--'),
                                ('all', 'All Paths'),
                                ('shortest', 'Choose the number of shortest paths')])
    shortestPath = IntegerField('Number of shortest paths: *',
                                widget=NumberInput(min=0, max=10000, step=1),
                                validators=[InputRequired()])

    continue_button = SubmitField('Continue')


class RealisticAnalysisDataForm(Form):
    realistic_analysis = StringField('Realistic Analysis name/description: *',
                                     validators=[InputRequired(),
                                                 Length(min=1, max=50,
                                                        message='Realistic Analysis name/description string must be between '
                                                                '1 and 50 characters long.')])
    topology_list = SelectField('Choose the topology: ', coerce=int,
                                validators=[InputRequired()])
    stub = MultiCheckboxField(choices=[(1, 'Include stub ASs')], coerce=int)
    cluster_list = MultiCheckboxField('Choose the servers on which to spawn the topology: ',
                                      coerce=int, validators=[InputRequired(message='Check at least one cluster node')])
    topology_distribution_method_list = SelectField('Choose how to spawn the topology on cluster nodes: ',
                                                    coerce=int, validators=[InputRequired()])
    router_platform = SelectField('Choose which BGP router to use: ',
                                  coerce=int, validators=[InputRequired()])
    emulation_platform = SelectField('Choose wich emulation platform to use: ',
                                     coerce=int, validators=[InputRequired()])


@view_config(route_name='hijack', renderer='minisecbgp:templates/hijack/hijackHistory.jinja2')
def hijack(request):
    user = request.user
    if user is None:
        raise HTTPForbidden

    dictionary = dict()

    return dictionary


@view_config(route_name='hijackAffectedArea', renderer='minisecbgp:templates/hijack/hijackAffectedArea.jinja2')
def hijackAffectedArea(request):
    user = request.user
    if user is None:
        raise HTTPForbidden

    dictionary = dict()

    try:
        form = AffectedAreaDataForm(request.POST)
        dictionary['form'] = form

        if request.method == 'POST' and form.validate():
            form = AffectedAreaDataForm()
            dictionary['form'] = form

    except Exception as error:
        dictionary['message'] = error
        dictionary['css_class'] = 'errorMessage'

    return dictionary


@view_config(route_name='hijackRealisticAnalysis',
             renderer='minisecbgp:templates/hijack/hijackRealisticAnalysis.jinja2')
def hijackRealisticAnalysis(request):
    user = request.user
    if user is None:
        raise HTTPForbidden

    dictionary = dict()
    try:
        form = RealisticAnalysisDataForm(request.POST)

        form.topology_list.choices = [(row.id, row.topology) for row in
                                      request.dbsession.query(models.Topology).order_by(models.Topology.topology)]

        form.cluster_list.choices = [(row.id, ipaddress.ip_address(row.node)) for row in
                                     request.dbsession.query(models.Node).filter(models.Node.all_services == 0).filter(
                                         models.Node.all_install == 0).order_by(models.Node.node)]

        form.topology_distribution_method_list.choices = [(row.id, row.topology_distribution_method) for row in
                                                          request.dbsession.query(models.TopologyDistributionMethod)]

        form.emulation_platform.choices = [(row.id, row.emulation_platform) for row in
                                           request.dbsession.query(models.EmulationPlatform)]

        form.router_platform.choices = [(row.id, row.router_platform) for row in
                                        request.dbsession.query(models.RouterPlatform)]

        if request.method == 'POST' and form.validate():
            try:
                realistic_analysis = models.RealisticAnalysis(id_topology=form.topology_list.data,
                                                              id_topology_distribution_method=form.topology_distribution_method_list.data,
                                                              id_emulation_platform=form.emulation_platform.data,
                                                              id_router_platform=form.router_platform.data,
                                                              realistic_analysis=form.realistic_analysis.data)
                request.dbsession.add(realistic_analysis)
                request.dbsession.flush()
            except IntegrityError:
                request.dbsession.rollback()
                dictionary['message'] = 'The Realistic Analysis name/description "%s" already exist. Choose another ' \
                                        'name/description.' % form.realistic_analysis.data
                dictionary['css_class'] = 'errorMessage'

            if form.router_platform.data == 1:  # Quagga

                df_autonomous_system = pd.read_sql(request.dbsession.query(models.AutonomousSystem).
                                                   filter_by(id_topology=form.topology_list.data).statement,
                                                   request.dbsession.bind,
                                                   index_col=['id'])

                df_link = pd.read_sql(request.dbsession.query(models.Link).
                                      filter_by(id_topology=form.topology_list.data).statement,
                                      request.dbsession.bind,
                                      index_col=['id'])

                df_link.reset_index()
                df_link.set_index('id_autonomous_system1', inplace=True)
                df_link = pd.concat([df_link, df_autonomous_system['autonomous_system']], axis=1, join='inner')
                df_link = df_link.reset_index().rename(columns={'index': 'id_autonomous_system1'})
                df_link = df_link.rename(columns={'autonomous_system': 'autonomous_system1'})

                df_link.reset_index()
                df_link.set_index('id_autonomous_system2', inplace=True)
                df_link = pd.concat([df_link, df_autonomous_system['autonomous_system']], axis=1, join='inner')
                df_link = df_link.reset_index().rename(columns={'index': 'id_autonomous_system2'})
                df_link = df_link.rename(columns={'autonomous_system': 'autonomous_system2'})

                df_link['link1'] = 'interface ' + \
                                   df_link['autonomous_system1'].astype(str) + \
                                   '-' + \
                                   df_link['autonomous_system2'].astype(str) + \
                                   '\nip address ' + \
                                   [str(ipaddress.ip_address(i)) for i in df_link['ip_autonomous_system1']] + \
                                   '/' + \
                                   df_link['mask'].astype(str)

                df_link['link2'] = 'interface ' + \
                                   df_link['autonomous_system2'].astype(str) + \
                                   '-' + \
                                   df_link['autonomous_system1'].astype(str) + \
                                   '\nip address ' + \
                                   [str(ipaddress.ip_address(i)) for i in df_link['ip_autonomous_system2']] + \
                                   '/' + \
                                   df_link['mask'].astype(str)

                df_link_temp_autonomous_system1 = df_link[['id_autonomous_system1', 'autonomous_system1', 'link1']]
                df_link_temp_autonomous_system1.columns = ['id_autonomous_system', 'autonomous_system', 'link']
                df_link_temp_autonomous_system2 = df_link[['id_autonomous_system2', 'autonomous_system2', 'link2']]
                df_link_temp_autonomous_system2.columns = ['id_autonomous_system', 'autonomous_system', 'link']

                df_realistic_analysis_detail = pd.concat([df_link_temp_autonomous_system1, df_link_temp_autonomous_system2], axis=0)
                df_realistic_analysis_detail = \
                    df_realistic_analysis_detail.groupby(['id_autonomous_system', 'autonomous_system'])['link'].apply(
                        lambda x: '\n\n'.join(x.astype(str))).reset_index()

                #pd.set_option('display.max_colwidth', None)
                #print(df_y)
                #os.system('echo "%s" > teste.txt' % df_y)

                df_realistic_analysis_detail['link'] = '! -*- zebra -*-\n\nhostname ' + \
                                                       df_realistic_analysis_detail.autonomous_system.map(str) + \
                                                       '\npassword en\nenable password en\n\ninterface lo\nip address 127.0.0.1/32\n\n' + \
                                                       df_realistic_analysis_detail.link.map(str) + \
                                                       '\nlog file /tmp/' + df_realistic_analysis_detail.autonomous_system.map(str) + '.log'

                #pd.set_option('display.max_colwidth', None)
                #print(df_realistic_analysis_detail)
                #os.system('echo "%s" > teste.txt' % df_realistic_analysis_detail)






                # já posso fazer o route-map aqui
                # --> aqui



                #df_autonomous_system = df_autonomous_system.reset_index().rename(columns={'id': 'id_autonomous_system'})

                #df_router_conf = pd.DataFrame(data=df_autonomous_system['id_autonomous_system'])
                #df_router_conf.set_index('id_autonomous_system', inplace=True)
                #df_link.set_index('id_autonomous_system1', inplace=True)
                #print(df_router_conf)
                #df_router_conf['router_conf'] = df_router_conf['router_conf'].astype(str)

                #realistic_analysis_detail = {'id_autonomous_system': df_autonomous_system['id_autonomous_system'],
                #                             'id_realistic_analysis': realistic_analysis.id}
                #df_realistic_analysis_detail = pd.DataFrame(data=realistic_analysis_detail)

                #print(df_realistic_analysis_detail)




        availability = True
        all_installs = request.dbsession.query(models.Node.all_install).all()
        for all_install in all_installs:
            if all_install == 2:
                availability = False
        downloading = request.dbsession.query(models.DownloadingTopology).first()
        if downloading.downloading == 1:
            availability = False

        if not availability:
            dictionary[
                'message'] = 'Warning: there is an update process running in the background (cluster nodes or topology). ' \
                             'Wait for it finish to access Realistic Analysis again.'
            dictionary['css_class'] = 'warningMessage'

        dictionary['form'] = form
        dictionary['availability'] = availability

    except Exception as error:
        request.dbsession.rollback()
        dictionary['message'] = error
        dictionary['css_class'] = 'errorMessage'

    return dictionary
